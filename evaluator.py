# Used to evaluate the AST generated by the parser
class Evaluator:
    def __init__(self, root):
        self.root = root
        self.variables = {}
        self.eval(root)

    # Recursively evaluate nodes in the AST
    def eval(self, node):
        if not node:
            return None
        if node.type == "STATEMENTS":
            for stmt in node.down:
                self.eval(stmt)
        elif node.type == "ASSIGN":
            self.variables[node.value] = self.eval(node.right)
        elif node.type == "DISPLAY":
            value = self.variables.get(node.value)
            if value is not None:
                print(value)
            else:
                print(node.value)
        elif node.type == "NUM":
            return node.value
        elif node.type == "ID":
            if node.value in self.variables:
                return self.variables[node.value]
            else:
                raise ValueError(f"Undefined variable: {node.value}")
        elif node.type == "NEG":
            return -1 * self.eval(node.down)
        elif node.type == "EXP":
            base = self.eval(node.left)
            exponent = self.eval(node.right)
            if base < 0 and int(exponent) != exponent:
                raise ValueError("Exponentiation with a negative base and non-integer exponent")
            return base ** exponent
        elif node.type == "MUL":
            return self.eval(node.left) * self.eval(node.right)
        elif node.type == "DIV":
            right_value = self.eval(node.right)
            if right_value == 0:
                raise ZeroDivisionError("Error: Division by zero")
            return self.eval(node.left) / right_value
        elif node.type == "ADD":
            return self.eval(node.left) + self.eval(node.right)
        elif node.type == "SUB":
            return self.eval(node.left) - self.eval(node.right)